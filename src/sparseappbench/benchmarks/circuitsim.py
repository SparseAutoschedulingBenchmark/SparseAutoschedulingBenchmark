"""
Name: Circuit Simulation Solver
Author: Akarsh Duddu
Email: aduddu3@gatech.edu
Motivation (Importance of problem with citation):
Efficiently solving DC operating points for large-scale nonlinear
circuits in SPICE simulation is both critical and challenging.
Jiang, Jiqing, et al.
“Boosting the Performance of Transistor-Level Circuit Simulation with GNN.”
Proceedings of the 30th Asia and
South Pacific Design Automation Conference, 20 Jan. 2025,
pp. 114–120, www.ssslab.cn/assets/papers/2025-jiang-boosting.pdf,
https://doi.org/10.1145/3658617.3703149. Accessed 6 Dec. 2025.
Role of sparsity (How sparsity is used in the problem):
With large-scale circuit simulations, such as nodal analysis,
most matrices are sparse due to non-dense connectivity in the system.
Data Generation (How is the data generated? Why is it realistic?):
For large circuits, a matrix is produced by a netlist through MNA analysis.
For smaller circuits (like RC and RLC circuits), data is generated by a
differential equation and a starting state.
AI Generation Statement:
No generative AI was used to write the benchmark function itself. Generative
AI was used for debugging. This statement was written by hand.
"""

from functools import partial

import numpy as np


def forward_euler(
    xp,
    dydx,
    span,
    y0,
    first_step,
):
    """Forward Euler method of approximating ordinary differential equations (ODEs)."""
    # Builtin range function does not support floating-point step
    curr = span[0]
    inputs = []
    while curr < span[1]:
        inputs.append(curr)
        curr += first_step

    step = first_step
    outputs = [None for _ in inputs]
    outputs[0] = y0

    for i in range(1, len(inputs)):
        # y_new = y + dy/dx * delta x

        dydt_vector = dydx(inputs[i - 1], outputs[i - 1])
        outputs[i] = [outputs[i - 1][j] + dydt_vector[j] * step for j in range(len(y0))]

    return (inputs, outputs)


def step_input(t):
    """A simple 5V step input starting at t=0."""
    return 5.0 if t >= 0 else 0.0


def rc(t, Vc, R, C, Vs_func):
    """Differential equation for RC Circuit voltage."""
    tau = R * C
    Vs = Vs_func(t)  # Get the current source voltage
    return [(Vs - Vc[0]) / tau]  # dV/dt


def dg_forward_euler_rc(R, C, t_max, V_C_initial):
    """Data Generator for Forward Euler with RC Circuit."""
    dVdt = partial(rc, R=R, C=C, Vs_func=step_input)
    # dVdt = lambda t, Vc: rc_ode(t, Vc, R, C, step_input)

    return (np, dVdt, (0, t_max), [V_C_initial], t_max / 1000)


def rlc(
    t,
    state,
    R,
    L,
    C,
    Vs_func,
):
    """Differential equation for RLC Circuit voltage."""
    Vc = state[0]
    dVc = state[1]  # dx1/dt = x2

    Vs = Vs_func(t)

    d2Vc = (Vs - Vc - R * C * dVc) / (L * C)  # dx2/dt = (Vs - x1 - RCx2) / LC
    return (dVc, d2Vc)


def dg_forward_euler_rlc(R, L, C, t_max, y0):
    """Data Generator for Forward Euler with RLC Circuit."""
    dVdt = partial(rlc, R=R, L=L, C=C, Vs_func=step_input)
    # dVdt = lambda t, y: rlc(t, y, R, L, C, step_input)
    return (np, dVdt, (0, t_max), y0, t_max / 1000)


def lotka_volterra(t, state, a, b, c, d):
    x, y = state
    dxdt = a * x - b * x * y
    dydt = d * x * y - c * y
    return (dxdt, dydt)


def dg_forward_euler_lotka_volterra(a, b, c, d, y0):
    """Data Generator for Forward Euler with Lotka-Volterra Equations."""
    dydt = partial(lotka_volterra, a=a, b=b, c=c, d=d)
    # dydt = lambda t, y: lotka_volterra(t, y, a, b, c, d)

    # Solve
    return (np, dydt, (0, 30), y0, 1)
